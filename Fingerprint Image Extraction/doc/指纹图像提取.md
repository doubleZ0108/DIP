# 指纹图像提取项目文档

[TOC]

------

## 项目背景

从iPhone5s搭载TouchID之后，指纹身份验证已经普及进了家家户户，从前令人难以琢磨的指纹信息与人身份的匹配问题也被科学家击破。

本次实验中，我们先不考虑如何对不同的指纹进行唯一的识别，我们先来看一步更重要的部分——如何进行指纹图像的提取，提取后的指纹效果关系到最终识别时到准确度和指纹信息的可靠性等多种因素，因此找到更好、更快的指纹图像提取算法十分重要。

------

## 阈值处理

一幅图像包括目标物体、背景还有噪声，要想从多值的数字图像中直接提取出目标物体，常用的方法就是设定一个阈值T，用T将图像的数据分成两部分：大于T的像素群和小于T的像素群。这是研究灰度变换的最特殊的方法，称为图像的二值化（Binarization）。

**公式：**
$$
g(x,y) = \begin{equation}  
\left\{  
             \begin{array}{**lr**}  
             1, & f(x,y)>T  \\  
             0, & f(x,y)\leq T
             \end{array}  
\right.  
\end{equation}
$$
**特点：** 适用于目标与背景灰度有较强对比的情况，重要的是背景或物体的灰度比较单一，而且总可以得到封闭且连通区域的边界。

**例子：**

- 如图a中我们可以明显的看到像素在T附近具有明显界限，因此将T作为阈值，可以划分两部分的像素值，达到图像提取的目的
- 如图b中我们可以看到在T1和T2两处具有明显的界限，因此可以将0~T1, T1~T2, T2~255划分成三部分像素区间

<img src="../../../../Library/Application Support/typora-user-images/image-20191214194958949.png" alt="image-20191214194958949" style="zoom:50%;" />

### 图像阈值处理中噪声的作用

- **图像a：**只有两种像素，没有任何招生，因此其直方图由两个波峰组成
  - 根据直方图d，对图a进行分割十分容易，选取两个模式之间的任何位置作为阈值都可以很好的进行图像分割
- **图像b：**在原图中添加了均值为0、标准差为10个灰度级的高斯噪声
  - 根据直方图e，尽管相应的直方图模式较宽，但是仍可以明显看到分界，在两个波峰之间的中间位置的阈值可以很好的分割图像
- **图像c：**在原图中施加均值为0、标准差为50个灰度级的高斯噪声
  - 根据直方图f，现在由于被噪声污染很严重，导致没法直观的寻找到合适的阈值进行图像分割

<img src="../../../../Library/Application Support/typora-user-images/image-20191214195207924.png" alt="image-20191214195207924" style="zoom:50%;" />

### 图像阈值处理中光照和反射的作用

- **图像a：**上图中的图b

- **图像b：**非均匀光照的影响

- **图像c：**图a与图b的乘积

  - 根据直方图f，波峰之间的较深的波谷在模式的分离点处被污染，如果没有附加的处理，分离事不可能的

  - 如果光照非常均匀，但图像的反射不均匀也会得到类似的结果

    > 例如. 物体的表面或背景自然翻身变化的情况就是如此

    

<img src="../../../../Library/Application Support/typora-user-images/image-20191214195850933.png" alt="image-20191214195850933" style="zoom:50%;" />

------

## 简单阈值

**ret, dst = cv2.threshold(src, thresh, maxval, type)**

- src： 输入图，只能输入单通道图像，通常来说为灰度图

- thresh： 阈值

- maxval： 当像素值超过了阈值（或者小于阈值，根据type来决定），所赋予的值

- type：二值化操作的类型，包含以下5种类型：

  - cv2.THRESH_BINARY ：正向二值化,如果当前的像素值大于设置的阈值(thresh)，则将该点的像素值设置为maxval；否则，将该点的像素值设置为0；

    具体的公式如下：
    $$
    dst(x,y) = \begin{equation}  
    \left\{  
                 \begin{array}{**lr**}  
                 Max Value, & if \ src(x,y) > threshold   \\  
                 0, & otherwise
                 \end{array}  
    \right.  
    \end{equation}
    $$

  - cv2.THRESH_BINARY_INV ：反向二值化，如果当前的像素值大于设置的阈值(thresh)，则将该点的像素值设置为0；否则，将该点的像素值设置为maxval；
    具体的公式如下：
    $$
    dst(x,y) = \begin{equation}  
    \left\{  
                 \begin{array}{**lr**}  
                 0, & if \ src(x,y) > threshold  \\  
                 Max Value, & otherwise
                 \end{array}  
    \right.  
    \end{equation}
    $$
    
- cv2.THRESH_TRUNC ：如果当前的像素值大于设置的阈值(thresh)，则将该点的像素值设置为threshold；否则，将该点的像素值不变；
    具体的公式如下：
    $$
    dst(x,y) = \begin{equation}  
    \left\{  
                 \begin{array}{**lr**}  
                 threshold, &   if \ src(x,y) > threshold\\  
                 src(x,y), & otherwise
                 \end{array}  
    \right.  
    \end{equation}
    $$
  
- cv2.THRESH_TOZERO ：如果当前的像素值大于设置的阈值(thresh)，则将该点的像素值不变；否则，将该点的像素值设置为0；
    具体的公式如下：
    $$
    dst(x,y) = \begin{equation}  
    \left\{  
                 \begin{array}{**lr**}  
                  src(x,y), &  if \ src(x,y) > threshold \\  
                 0, & otherwise
                 \end{array}  
    \right.  
    \end{equation}
    $$
  
- cv2.THRESH_TOZERO_INV：如果当前的像素值大于设置的阈值(thresh)，则将该点的像素值设置为0；否则，将该点的像素值不变；
    具体的公式如下：
    $$
    dst(x,y) = \begin{equation}  
    \left\{  
                 \begin{array}{**lr**}  
                 0, &  if \ src(x,y) > threshold \\  
                  src(x,y), & otherwise
                 \end{array}  
    \right.  
    \end{equation}
    $$
    

### 算法实现

```python
def Basic_Thresholding(img):
    '''
    :description: 简单阈值处理

    :param img: 灰度图像

    :return : 阈值处理后的图像
    '''
    blurred = cv2.GaussianBlur(img, (5, 5), 0)
    (T, thresh_inv) = cv2.threshold(blurred, 127, 255, cv2.THRESH_BINARY_INV)
    return thresh_inv
  
image = cv2.imread('../Resources/snow.png')
gray = cv2.cvtColor(image, cv2.COLOR_BGRA2GRAY)     # rgb图像变换为灰度图像

thresh_inv = Basic_Thresholding(gray)   # 阈值处理后的图像

image_mask = cv2.bitwise_and(gray, gray, mask=thresh_inv)   # 在阈值处理后的图像上加掩膜
```

### 算法效果

**原图**

<img src="../Resources/original.png" alt="original" style="zoom:50%;" />

**简单阈值处理后的图像**

<img src="../Resources/thresh_inv.png" alt="thresh_inv" style="zoom:50%;" />

**增加掩膜**

<img src="../Resources/image_mask.png" alt="image_mask" style="zoom:50%;" />
